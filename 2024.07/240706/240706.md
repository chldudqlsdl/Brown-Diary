## MVVM

- 뷰 로직과 비즈니스 로직을 분리하는 것
- ViewModel 에서는 View 를 위한 상태와 메서드 정의하고, View 는 ViewModel 의 상태변화를 옵저버 패턴을 통해 관찰 → 데이터 바인딩
- ViewModel 은 View 를 위해 Model 의 데이터를 가공해서 View 에게 전달
- Model 은 데이터를 처리 및 저장

- 장점
    - 뷰 로직 비즈니스 로직 분리했기에 테스트 및 유지보수 용이
    - UI 디자인이 나오지 않아도 뷰모델 먼저 개발 가능

## 옵저버 패턴

- 객체간의 의존성을 줄이고, 객체간의 상호 의존성을 느슨하게 만들기 위한 디자인 패턴
- 객체의 상태가 변화할 때 그를 관찰하는 구독자에게 이벤트를 발생시켜주는
- OCP - 확장에는 열려있고, 수정에는 닫혀있는
- Publisher 와 Observer 가 인터페이스를 통해 느슨하게 결합
- Publisher 갑 Observer 을
- 새 구독자가 생기면 인터페이스만 준수 해주면 된다

## MVC / MVVM

- 애플은 ViewController 라는 단어만 봐도, MVC 를 추구하여 설계
- View 와 Model 의 완전한 분리를 지향 → View 와 Model 의 소통을 위해서는 반드시 VC 를 거쳐야 한다
- why? UI 재사용성을 극대화하기 위해

- 그런데 왜 MVVM 다 쓰나요?
- 애플의 MVC 는 문제가 있다 → View 와 VC 가 너무 강하게 결합된다는 것 ⇒ 유닛테스트 할 때도 불편
- MVVM 에서는 View 와 ViewController 를 묶어서 View

- 테스트용이성
    - VM 에서 UI 와 무관하게 로직을 처리하기에 별도로 테스트할 수 있다
- 유지보수성
    - M V VM 이 명확하게 나누어져 있어 코드의 유지보수와 확장이 용이

## 디자인 패턴의 정의

- 개발과정에서 자주 일어나는 문제를 해결하기 위한 개발자의 가이드
- 약속 된 패턴이 있기에 패턴만 이해하면 코드를 쉽게 이해할 수 있다

## 메모리관리

- 메모리 릭이란?
    - 사용하지 않는 인스턴스가 메모리에 남아, 메모리 공간이 낭비되는 현상
- 순환참조에 대해 설명해주세요
    - 두 객체가 서로를 참조할 때 발생하는데, iOS 는 메모리 관리를 ARC 가 해준다. 그런데 순환참조가 일어나면 자동으로 RC 를 내려주지 않는다! → 약한 참조
- 강한 참조 ∙ 약한 참조
    - RC 증가 시키냐 ∙ 안 시키냐
- Retain Count
    - ARC 의 메모리 관리 방식으로 RC 가 올라가는 것이 Retain 내려가는 것이 Release
- weak ∙ unowned
    - weak 은 참조대상이 메모리에서 해제되었을 때 nil 이 설정되는 옵셔널이고
    - unowned 은 참조대상이 메모리에서 해제되었을 때 nil 이 안되고 에러가 발생된다
    - 그렇다면 주인보다 더 오래 살아 있어야 겠네? → 인스턴스 해제 시점을 예민하게 고민
    - 옵셔널 해제 과정이 없기에 퍼포먼스 면에서 약간의 이점
- reference count 종류와 side Table 이 뭔가요?
    - strong unonwed weak 각각 rc 를 카운팅하는데
    - strong rc == 0 → deinit , unowned rc == 0 → dealloc , weak rc == 0 → freed
    - 좀비 오브젝트 → strong rc == 0 , weak rc > 0 → 메모리에서 완전 해제가 되지 않은 상황
    - **사이드 테이블은 약한 참조를 추적하여 객체 해제시 약한 참조를 nil 로 바꾸어 좀비가 못되게!**

## 힙 vs 스택

### 힙

- 메모리 할당 방식
    - 동적 크기 할당 : 필요한 메모리를 런타임에 결정하여 할당
    - 개발자가 수동으로 할당 ∙ 해제 → iOS 는 ARC
- 메모리의 크기와 위치
    - 더 큰 크기
- 접근 속도
    - 느린 접근 : 동적으로 할당되고 해제되므로, 메모리 접근 속도가 느리다
        - 이유 : 메모리 조각화 → 힙 메모리는 동적으로 크기와 위치가 다양한 블록으로 할당되고 해제되는데, 메모리 공간이 불연속적이라 메모리 블록 찾는데 시간 걸림

### 스택

- 메모리 할당 방식
    - 정적 크기 할당 : 필요한 메모리를 컴파일 타임에 결정하여 할당
    - 메모리 자동 할당 및 해제
    - LIFO
- 메모리의 크기와 위치
    - 제한된 크기 → 스택 오버 플로우
- 접근 속도
    - 빠르게 접근

### 이렇게 보면 스택이 엄청 좋아보이는데 왜 힙을 쓰죠? ⇒ 힙의 장점

- 런타임 크기 결정
    - 컬렉션은 크기가 고정되지 않아 런타임에 크기가 결정되는데 이럴 때 사용
- 객체의 수명 제어
    - 스택은 함수 호출과 함께 메모리 할당되고, 함수 종료되면 해제되므로 수명 컨트롤이 어렵다
- 큰 데이터 구조의 저장

### 아 컬렉션은 힙에 저장이었구나…?

- 구조체 내에 컬렉션이 있으면 구조체는 스택 저장 내부의 컬렉션은 힙에 저장

## 클래스 vs 구조체

### 클래스

- 참조타입 → 복사시 메모리 주소만 공유 ⇒ 복사효율이 좋겠지?

### 구조체

- 값 타입 → 통째로 복사

## 값 타입 vs 참조 타입

### 값타입

- 구조체 열거형 튜플
    - 컬렉션 타입은 구조체

### 참조타입

- 클래스
- 힙에 저장, ARC

### COW

- 스위프트의 컬렉션 타입에서 사용
- 복사본 생성시 실제 데이터 즉시 복사가 아니라, 참조 공유로 진행하고 → 값의 변경이 일어나면 비로소 복사
- 작동원리
    - 컬렉션 생성 → 힙에 저장 → 복사하면 참조 카운터 올라감 → 데이터를 변경하려고 하면 실제 데이터 복사 발생

## ARC / MRC / GC

### ARC ∙ MRC ?

- MRC 는 rc 를 계산하는데, retain ∙ release 메서드를 직접 작성

### ARC 는 컴파일 시점에 실행되나?

- 실행이 컴파일 시점에 되는 건 아니고, 컴파일 시점에 retain 과 release 코드를 적절한 위치에 삽입

### ARC 와 GC 의 차이점

- ARC - 컴파일 타임 , GC - 런타임
- ARC 는 런타임 성능이 좋아지는데, 앱 실행중 순환참조 발생 위험

## Delegate 패턴

- 객체 A가 해야하는 일을 객체 B에서 부분적으로 확장해서 대신 처리
- 객체간의 결합도를 낮추고, 유연한 앱 구조
- 느슨한 결합 → 객체를 쉽게 바꿀 수 있다

- DelegatePattern vs Notification
    - Noti → 다수의 객체들에게 이벤트 전달
    - Delegate → 다른 사람이 봤을 때 좀 더 직관적

## 앱상태

### RunLoops

- 스레드에서 외부입력소스를 처리하는 이벤트 처리 루프 및 Timer 를 처리할 때 사용
- current 메서드로 접근할 수 있고, 해당 스레드의 런루프가 없으면 생성! 됨
    - 생성되고 자동으로 실행되는 것도 아님
- 런루프는 두가지 이벤트를 수신함
    - Input Source ∙Timer
- Global Thread 에서 왜 Timer 가 실행되지 않는지?
    - Global Thread 에서는 런루프가 실행되고 있지 않고 그래서 Timer 를 처리를 못함
- Main Thread 에서는?
    - Main run Loop 는 UIApplication 에서 자동으로 실행
- **run(until:) → 이걸 많이 쓰는 듯**

### UIApplication

- 앱이 시작될 때, UIApplicationMain 함수가 호출 → UIApplication 객체를 생성 → Main Run Loop 설정 ∙ 실행
- UIApplication 은 앱의 주요 진입점으로, 앱의 초기 설정과 메인 이벤트 루프 실행
- 사용자 이벤트 → Main Run Loop → UIApplication 으로 전달
- 앱의 실행, 백그라운드 전환, 포그라운드 전환, 종료 등의 상태를 관리
- **정리하면 OS 와 사용자 인풋을 연결한다?**

### @main

- 프로그램이 진입점 → AppDelegate!!!!
- @UIApplicationMain 키워드는 struct 에서는 사용하기 어려운 구조였기 때문에 class 와 struct 를 모두 커버 가능한 @main 을 사용하게 되었습니다.

### AppLifeCycle → UIApplicationDelegate 상태 변화 처리

- Unattached : 앱이 실행되지 않은 상태, 메모리에 올라오지 않은 상태!
- Foreground : 앱이 화면에 보여지는 상태, 시스템 리소를  우선적으로 사용
    - Active : 앱이 실행중 ∙ 이벤트를 받을 수 있는 상태
    - InActive : 앱이 실행중이지만 → 전화 ∙ 알림 ⇒ 비활
- Background : 화면 점유는 안 하지만 동작은 하는 상태
- Suspend : 백그라운드에서 활동을 멈춘 상태 메모리에는 올라가 있는데, 메모리 부족하면 Suspend 에서 앱 내림

### iOS 13 이후에는 한 앱에서 여러 Scene 띄울 수 있고, 그에 따른 변수 발생

- UILifeCycle 은 SceneDelegate 가 처리함
    - willResignActive ∙ didBecomeActive 등등
- window → Scene 으로 대체
- UILifeCycle 을 SceneDelegate 가 처리하니까 UIApplicationDelegate 에서는 SceneSession 을 통해서 Scene 에 대한 정보를 받는다
