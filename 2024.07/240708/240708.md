## Class & Struct

### 비교

- Class - 참조타입 , Struct - 값타입
- 상속여부
- 핵심은 무엇이 전달되냐 - 인스턴스를 복사해서 전달하느냐? or 인스턴스의 주솟값을 전달하느냐?

### 복사방법 = COW

- 값타입 복사시 원본 리소스 공유하다가, 수정이 일어나는 경우에 복사
- **아 컬렉션 타입에만 사용하는거?**
- 시간적 오버헤드가 발생하지만, 메모리 공간을 절약할 수 있다

### final

- 상속을 안 하겠다는 뜻
- 메서드 디스패치 방식이 Dynamic → Static 으로 변경
- 오버헤드가 줄어서 성능 향상 → 메서드 디스패치가 빨라짐

## 타입캐스팅

### 타입을 바꾸는 것이 아니라 범위를 전환하는 것!

- 업캐스팅 → 무조건 성공
- 다운캐스팅 → 실패가능성 있음 ⇒ as? as!
- 타입은 여전히 그대로임

## 메서드 디스패치

### 개념

- 메서드 호출 매커니즘이 어떻게 되는지?
- 종류 : Static ∙Dynamic

### Static Dispatch

- 컴파일 시점에 어떤 메소드를 호출 할 지를 결정한다
- 성능이 좋다
- 구조체 ∙ 열거형 ∙ final

### Dynamic Dispatch(Table Dispatch)

- 런타임에 어떤 메소드를 호출할지 결정
- 함수의 포인터가 배열 형태로 테이블에 저장되어 있고, 이 테이블로 메서드를 찾으러 간다 → 상속이 있기 때문에 상위 클래스 하위 클래스 중 어떤 것을 참조해야 할지를 런타임 시점에 결정
- Table 종류는
    - Virtual Table - 클래스
    - Witness Table - 프로토콜

### VirtualTable

- 하위 클래스는 상위 클래스의 가상 테이블 복사본을 가지고 있는다

### 코데힙스

- 메서드는 코드 영역에 저장
- 정적변수 버츄얼테이블은 데이터 영역 저장
- 인스턴스 및 인스턴스 변수는 힙에 저장

## 접근제어자

### 종류

- Open : 클래스와 클래스 멤버, 외부 모듈에서도 접근 할 수 있다 + 재정의 가능
- Public : 외부 모듈에서 접근 가능 + 재정의는 불가
- internel : 모듈 내부에서만 접근 가능
- fileprivate : 동일한 파일 내부에서만 접근 가능
- private : 같은 파일 내에서도 같은 클래스나 구조체에서만 접근가능

### 특징

- 하위요소가 상위요소 보다 더 높은 접근 수준을 가질 수 없다
- 모듈 → 앱 ∙ 프레임워크 ∙ 라이브러리는 각각의 모듈이다

### Open ∙Public 비교해 보세요

- Open Publich 둘다 외부 모듈에서 접근 할 수 있다
- Open 은 클래스와 클래스 멤버에만 사용가능, 상속 ∙ 재정의 가능
- Public 클래스 말고도 다 사용가능 but 상속 ∙ 재정의 불가

## 이니셜라이저

### 지정생성자

- 모든 저장 속성 초기화
- 하위 클래스 지정생성자는 상위 클래스 지정 생성자를 반드시 호출

### 편의생성자

- 다른 생성자를 반드시 호출해야함

### 필수생성자

- 하위클래스들이 반드시 재정의해야하는 생성자
- 하위클래스에 아무런 생성자도 구현하지 않으면 상위 클래스의 생성자가 자동 상속
- 뭐라도 건드리면 필요생성자 구현해줘야함

## 확장

- 메서드 추가가능
- 연산프로퍼티는 메서드여서 추가 가능

## Optional

- 제네릭이 적용된 열거형으로 구현되어 있다
- @frozen 이 붙어 있어서 케이스 추가가 안됨을 보장

## 열거형

### 개념

- 연관된 값을 그룹화하여 표현할 수 있는 데이터 타입
- 코드의 가독성과 안정성이 높아집니다
- 원시값 연관값 활용가능

### 원시값

- 타입 써줄 수 있음

### 연관값

- 튜플형태로 원하는 타입 명시해서 사용
- 상세한 정보

## 컬렉션 타입

- 배열 : 데이터를 순서대로 저장
- 딕셔너리 : Hashable 프로토콜
    - 키값은 Hashable 해야함 → Hash 함수의 인풋 값으로 사용할 수 있어야 함
        - Swift 기본 데이터 타입은 Hashable 함
    - 인풋 값을 고유한 Hash 값으로 바꿔준다
    - 값의 유일성을 보장하고 검색 속도가 빠르다
- 세트 : 순서가 중요하지 않고, 데이터를 중복없이 고유하게 관리할 때는 Set
    - 삽입 삭제 조회 O(1)
- Any ∙ AnyObject

## 클로저

### 값 캡쳐

- 클로저를 변수에 저장할 때, 외부에 있는 값을 캡쳐하는데 타입에 관계 없이 참조해버림
- 캡쳐리스트를 사용하면 참조가 아니라 상수로 캡쳐가 가능

### 강한 순환 참조

- 클래스 내부에서 클로저를 사용하고, 그 클로저 내부에서 self 를 캡쳐하면 강한 순환 참조 이슈 발생
- 캡쳐리스트 사용하여 weak self 를 사용해주면 RC 값을 증가시키지 않습니다

### 후행 클로저

- 파라미터의 마지막 요소가 클로저일 때, 소괄호 밖에 클로저 적을 수 있음
- 가독성이 높다

### @escaping

- **함수 파라미터로 전달한 클로저가 함수 종료 이후에 호출될 때 사용**
- 함수는 스택 영역에서 실행되고 사라지는데, 이 때 안 사라지게 해야하는 이유가 있으면 escaping 키워드를 사용하면 얘가 클로저를 힙에 저장한다 → 저장 기간이 늘어남
- 그럼 어떤 상황에서 사용?
    - 외부 변수에 클로저를 저장하는 상황
    - 비동기 작업을 하는 상황 → 기존의 스택 프레임 흐름에서 빼와야 함

## ARC

### weak 은 객체를 직접 참조하는게 아니라 사이드테이블을 참조한다

- 그래서 확실할 때는 unowned 사용하는데 오버헤드 방지

## 프로토콜

### 개념

- 객체가 어떤 역할을 하기 위한 인터페이스를 정의하는 것
- 다형성을 구현할 수 있다
- 프로토콜은 기능 구현을 할 수 없지만, 추상 표현을 할 수 있다
- 프로토콜 + Extension ⇒ 기능 구현 + 추상 표현
- 선택적 요구사항 지정 가능 → @objc optional 붙이면 됨

### associated Type

- 프로토콜 내에서 제네릭 구현하고 싶을 때 사용가능

### Codable

- Encodable + Decodable

### Equatable

- 타입끼리 비교 연산(==)을 하기 위해 필수적으로 구현해야 하는 프로토콜
- 구조체 : 프로퍼티가 모두 기본타입이면 바로 채택가능
- 클래스 : 메서드를 구현해줘야 함

### Hashable

- 구조체는 Hashable 을 채택하기만 하면 됨
- 클래스는 직접 Hash 함수를 구현해줘야 함

## 키워드

### mutating 키워드

- 구조체나 열거형은 내부에서 변수 값을 변경할 수 없다
- mutating 붙여주면 변경이 가능하다

### lazy

- 지연할당 프로퍼티
- 클래스나 구조체가 초기화될 때 가 아니라, 프로퍼티가 호출될 때 초기화한다. 상수가 아닌 변수로 저장
- 성능저하나 공간낭비를 줄일 수 있다
- 문제점
    - 다중 스레드 환경에서 지연 저장 프로퍼티에 여러 스레드에서 접근하면 여러번 초기화되는 문제 발생 가능

## 패러다임

### 고차함수

- 함수를 파라미터로 사용하거나, 함수의 실행 결과로 함수를 리턴하는 함수
- map : 초기값과 클로저를 받아서 결과를 반환
    - 기존 데이터를 변형하지 않고, 새로운 값을 반환
- filter : 필터링
- reduce : 컬렉션 요소를 하나로 합치기
- flatmap : nil 제거 + 2차원 배열을 1차원 배열로
- compactmap : nil 제거 + 2차원 배열 그대로 리턴

### 객체지향프로그래밍 → 객체 중심 ⇒ Class 사용 ∙ 프로퍼티 - 상태 ∙ 메서드 - 동작

- 캡슐화
    - 연관 있는 속성과 메서드들을 하나의 캡슐로 만드는 것
- 상속
    - 상위 클래스의 속성과 메서드를 물려받는 것
- 추상화
    - 복잡한 시스템으로 부터 불필요한 세부사항을 감추고, 중요한 속성과 행동만을 드러내는 것
- 다형성
    - 하나의 객체가 여러 타입으로 저장될 수 있고, 하나의 메서드가 여러 형태를 갖출 수 있다

### SOLID 원칙

- 단일 책임 원칙 (Single Responsibility)
    - 클래스는 하나의 책임만 가져야 한다
- 개방 / 폐쇄 원칙 (Open / Closed)
    - 클래스는 확장에는 열려있고, 변경에 대해서는 닫혀있어야 한다
- 리스코프 치환 원칙 (Liskov Substitution Principle)
    - 서브타입은 기반타입으로 교체가 가능해야 한다!
        - 상속시 부모 클래스에서 사용 가능한 행위는 자식 클래스에서 수행 보장 되어야 한다
- 인터페이스 분리 원칙 (Interface Segregation )
    - 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않아야 한다
- 의존 역전 원칙 ( Dependency Inversion Principle)
    - 고수준 모듈은 저수준 모듈에 의존해선 안된다, 추상화는 구체적인 사항에 의존해서는 안된다

### 프로토콜 지향 프로그래밍

- 프로토콜의 확장을 통해 기본 구현 제공 가능
- 섞어서 잘 쓰자

## Function & Method

### 개념

- 특정 객체에 소속되어 있으면 Method

### 인스턴스 메서드 & 타입메서드 & 클래스메서드

- 인스턴스 메서드 : 우리가 잘 아는 그 메서드
- 타입 메서드(Static) : 타입 자체에서 호출이 가능한 메서드
- **클래스 메서드 : 상속 후에 재정의 가능!**

### 외부의 값 타입 데이터를 바꾸고 싶다면 (참조타입은 그냥 가능?) ⇒ inOut

- 그르치 상수값으로 전달되니까 복사되어 전달되므로 바꿀 수가 없죠
- inOut 키워드 사용 → 메모리 주소를 전달받겠다는 이야기

### Defer

- 특정 코드블럭을 함수의 가장 마지막에 실행하게 해준다

## 프로퍼티

### 저장프로퍼티 & 연산프로퍼티

- 저장프로퍼티 : 값 저장
- 연산프로퍼티 : 값을 저장하지 않고, 인스턴스 내부 또는 외부값으로 연산
